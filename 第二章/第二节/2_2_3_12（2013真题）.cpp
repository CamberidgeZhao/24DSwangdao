/*
	n个数字保存在一维数组当中，如果有一个数字出现的次数超过了n/2，则称这个味主元素，如果有主元素就输出主元素，如果没有主元素就输出-1

	一个朴素的想法:
		先对于这个序列进行排序，然后从前向后扫描这个序列，如果这个时候发现这个时候的和前面的相同，就对一个计数器+1，如果在某个时候发现这个计数器的数字大于n/2,这个时候就判定现在这个数为主元素
		这个算法的时间复杂度为 nlogn+n ,用O表示法应该为 O(logn),空间复杂度为O(1)
	
	如果后序继续优化出更加便捷的算法，那期待他的时间复杂度应该为O(n)或者O(logn)

	上面我写出的算法可以拿到11分


	优化算法:
		如果存在这样一个主元素，那么意味着任何一个长n/2的子序列中都有这样的一个数字
	
*/

#include <iostream>
#include <algorithm>

using namespace std;

int fun(int a[],int n){//我的朴素算法的实现代码
	/**
	 * 这个算法虽然拿不到满分但是也可以拿到11分
	*/
	sort(a,a+n);//排序
	int count = 1;//计数器
	for(int i=1;i<n;i++){
		if(a[i]==a[i-1])
			count++;//和前面一个数相同说明在重复，++
		else 
			count=1;//说明不在重复，是一个新的数了，将计数器再次置置为1
		if(count>n/2)//出现了主元素
			return a[i];//返回主元素
	}
	return -1;//说明一直没有出现主元素，返回-1
}

/**
 * 下面来看看标准答案给出的满分算法吧
 * 
 * 满分算法的思想：
 * 将整个过程分为两个步骤	1.在所有的数字当中选择出出现次数最多的元素（也就是最有可能是主元素的元素） 2.去扫描数组，统计这个数字出现的次数来确定这是不是主元素
 * （在我看来这个算法当中最值得学习的是这个寻找出现次数最多元素的算法）
 * 1.将其中遇到的第一个数字保存在c当中，并设置一个记录count，如果下个数字和这个数字相同，那么+1，如果下个数字和这个数字不同就-1，当计数器减为0的时候就
 * (在这里需要更正一下，找到的并不是其中包含的最多的数字，只是有可能是大于n/2的数字，因为如果有一个数字是大于n/2的那么到最后这里面保存的一定是这个数字，如果没有，那里面是什么就不好说了)
 * 2.扫描数组查看c出现的次数是不是超过了n/2
*/

int Majority(int a[], int n){
	int c=a[0],count=1;
	
	for(int i=1;i<n;i++){
		if(c==a[i])
			count++;
		else {
			if(count>0)
				count--;
			else {
				c=a[i];
				count = 1;
			}
		}
	}
	if(count>0){
		count=0;
		for(int i=0;i<n;i++){
			if(a[i]==c) count++;
		}
	}
	if(count>n/2)
		return c;
	else 
		return -1;
}

int main(int argc, char *argv[]) {
	int n;
	cin>>n;
	int a[n];
	for(int i=0;i<n;i++)
		cin>> a[i];
	cout<<fun(a,n)<<endl;

	cout<<Majority(a,n)<<endl;

	return 0;
}